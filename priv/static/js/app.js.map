{"version":3,"sources":["c:/Projects/yacht/node_modules/phoenix/priv/static/phoenix.js","c:/Projects/yacht/node_modules/phoenix_html/priv/static/phoenix_html.js","c:/Projects/yacht/web/static/js/setup.js","c:/Projects/yacht/web/static/js/socket.js","web/static/js/app.js","web/static/js/roomcontroller.js","web/static/js/setup.js","web/static/js/socket.js"],"names":["window","currUser","cursorStates","drawing","mousePos","x","y","lastPos","mouseCanvas","document","getElementById","mouseCtx","getContext","collabCanvas","ctx","strokeStyle","lineWidth","clearCanvas","width","socket","params","token","userToken","connect","channel","join","receive","console","log","resp","on","moveTo","payload","from","lineTo","to","stroke","img","display","name","position","cursorKeys","Object","keys","forEach","currKey","drawImage","$","ready","baseName","Math","floor","random","val","requestAnimFrame","callback","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimaitonFrame","setTimeout","clearBtn","addEventListener","e","push","changeUserBtn","getMousePos","getTouchPos","touch","touches","mouseEvent","MouseEvent","clientX","clientY","canvas","dispatchEvent","body","target","preventDefault","canvasDom","rect","getBoundingClientRect","left","top","touchEvent","renderCanvas","drawLoop","yachtApp","controller","RoomController","$scope","users","color","angular","module"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3vCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;;;;;;AAMA;AACAA,OAAOC,QAAP,GAAkB,EAAlB;AACA;AACAD,OAAOE,YAAP,GAAsB,EAAtB;AACA;AACAF,OAAOG,OAAP,GAAiB,KAAjB;AACAH,OAAOI,QAAP,GAAkB,EAAEC,GAAE,CAAJ,EAAOC,GAAE,CAAT,EAAlB;AACAN,OAAOO,OAAP,GAAiBH,QAAjB;;AAEA;AACAJ,OAAOQ,WAAP,GAAqBC,SAASC,cAAT,CAAwB,cAAxB,CAArB;AACAV,OAAOW,QAAP,GAAkBH,YAAYI,UAAZ,CAAuB,IAAvB,CAAlB;;AAEA;AACAZ,OAAOa,YAAP,GAAsBJ,SAASC,cAAT,CAAwB,eAAxB,CAAtB;AACAV,OAAOc,GAAP,GAAaD,aAAaD,UAAb,CAAwB,IAAxB,CAAb;AACAE,IAAIC,WAAJ,GAAkB,SAAlB;AACAD,IAAIE,SAAJ,GAAg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","file":"priv\\static\\js\\app.js","sourcesContent":["\nrequire.register(\"phoenix/priv/static/phoenix.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix\");\n  (function() {\n    (function(exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Phoenix Channels JavaScript client\n//\n// ## Socket Connection\n//\n// A single connection is established to the server and\n// channels are multiplexed over the connection.\n// Connect to the server using the `Socket` class:\n//\n//     let socket = new Socket(\"/ws\", {params: {userToken: \"123\"}})\n//     socket.connect()\n//\n// The `Socket` constructor takes the mount point of the socket,\n// the authentication params, as well as options that can be found in\n// the Socket docs, such as configuring the `LongPoll` transport, and\n// heartbeat.\n//\n// ## Channels\n//\n// Channels are isolated, concurrent processes on the server that\n// subscribe to topics and broker events between the client and server.\n// To join a channel, you must provide the topic, and channel params for\n// authorization. Here's an example chat room example where `\"new_msg\"`\n// events are listened for, messages are pushed to the server, and\n// the channel is joined with ok/error/timeout matches:\n//\n//     let channel = socket.channel(\"room:123\", {token: roomToken})\n//     channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n//     $input.onEnter( e => {\n//       channel.push(\"new_msg\", {body: e.target.val}, 10000)\n//        .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n//        .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n//        .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n//     })\n//     channel.join()\n//       .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n//       .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n//       .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\") )\n//\n//\n// ## Joining\n//\n// Creating a channel with `socket.channel(topic, params)`, binds the params to\n// `channel.params`, which are sent up on `channel.join()`.\n// Subsequent rejoins will send up the modified params for\n// updating authorization params, or passing up last_message_id information.\n// Successful joins receive an \"ok\" status, while unsuccessful joins\n// receive \"error\".\n//\n// ## Duplicate Join Subscriptions\n//\n// While the client may join any number of topics on any number of channels,\n// the client may only hold a single subscription for each unique topic at any\n// given time. When attempting to create a duplicate subscription,\n// the server will close the existing channel, log a warning, and\n// spawn a new channel for the topic. The client will have their\n// `channel.onClose` callbacks fired for the existing channel, and the new\n// channel join will have its receive hooks processed as normal.\n//\n// ## Pushing Messages\n//\n// From the previous example, we can see that pushing messages to the server\n// can be done with `channel.push(eventName, payload)` and we can optionally\n// receive responses from the push. Additionally, we can use\n// `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n//  and take action after some period of waiting. The default timeout is 5000ms.\n//\n//\n// ## Socket Hooks\n//\n// Lifecycle events of the multiplexed connection can be hooked into via\n// `socket.onError()` and `socket.onClose()` events, ie:\n//\n//     socket.onError( () => console.log(\"there was an error with the connection!\") )\n//     socket.onClose( () => console.log(\"the connection dropped\") )\n//\n//\n// ## Channel Hooks\n//\n// For each joined channel, you can bind to `onError` and `onClose` events\n// to monitor the channel lifecycle, ie:\n//\n//     channel.onError( () => console.log(\"there was an error!\") )\n//     channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n//\n// ### onError hooks\n//\n// `onError` hooks are invoked if the socket connection drops, or the channel\n// crashes on the server. In either case, a channel rejoin is attempted\n// automatically in an exponential backoff manner.\n//\n// ### onClose hooks\n//\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n// closed on the server, or 2). The client explicitly closed, by calling\n// `channel.leave()`\n//\n//\n// ## Presence\n//\n// The `Presence` object provides features for syncing presence information\n// from the server with the client and handling presences joining and leaving.\n//\n// ### Syncing initial state from the server\n//\n// `Presence.syncState` is used to sync the list of presences on the server\n// with the client's state. An optional `onJoin` and `onLeave` callback can\n// be provided to react to changes in the client's local presences across\n// disconnects and reconnects with the server.\n//\n// `Presence.syncDiff` is used to sync a diff of presence join and leave\n// events from the server, as they happen. Like `syncState`, `syncDiff`\n// accepts optional `onJoin` and `onLeave` callbacks to react to a user\n// joining or leaving from a device.\n//\n// ### Listing Presences\n//\n// `Presence.list` is used to return a list of presence information\n// based on the local state of metadata. By default, all presence\n// metadata is returned, but a `listBy` function can be supplied to\n// allow the client to select which metadata to use for a given presence.\n// For example, you may have a user online from different devices with a\n// a metadata status of \"online\", but they have set themselves to \"away\"\n// on another device. In this case, they app may choose to use the \"away\"\n// status for what appears on the UI. The example below defines a `listBy`\n// function which prioritizes the first metadata which was registered for\n// each user. This could be the first tab they opened, or the first device\n// they came online from:\n//\n//     let state = {}\n//     state = Presence.syncState(state, stateFromServer)\n//     let listBy = (id, {metas: [first, ...rest]}) => {\n//       first.count = rest.length + 1 // count of this user's presences\n//       first.id = id\n//       return first\n//     }\n//     let onlineUsers = Presence.list(state, listBy)\n//\n//\n// ### Example Usage\n//\n//     // detect if user has joined for the 1st time or from another tab/device\n//     let onJoin = (id, current, newPres) => {\n//       if(!current){\n//         console.log(\"user has entered for the first time\", newPres)\n//       } else {\n//         console.log(\"user additional presence\", newPres)\n//       }\n//     }\n//     // detect if user has left from all tabs/devices, or is still present\n//     let onLeave = (id, current, leftPres) => {\n//       if(current.metas.length === 0){\n//         console.log(\"user has left from all devices\", leftPres)\n//       } else {\n//         console.log(\"user left from a device\", leftPres)\n//       }\n//     }\n//     let presences = {} // client's initial empty presence state\n//     // receive initial presence data from server, sent after join\n//     myChannel.on(\"presences\", state => {\n//       presences = Presence.syncState(presences, state, onJoin, onLeave)\n//       displayUsers(Presence.list(presences))\n//     })\n//     // receive \"presence_diff\" from server, containing join/leave events\n//     myChannel.on(\"presence_diff\", diff => {\n//       presences = Presence.syncDiff(presences, diff, onJoin, onLeave)\n//       this.setState({users: Presence.list(room.presences, listBy)})\n//     })\n//\nvar VSN = \"1.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 10000;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\n\nvar Push = function () {\n\n  // Initializes the Push\n  //\n  // channel - The Channel\n  // event - The event, for example `\"phx_join\"`\n  // payload - The payload, for example `{user_id: 123}`\n  // timeout - The push timeout in milliseconds\n  //\n\n  function Push(channel, event, payload, timeout) {\n    _classCallCheck(this, Push);\n\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || {};\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n      this.send();\n    }\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref\n      });\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({ status: status, callback: callback });\n      return this;\n    }\n\n    // private\n\n  }, {\n    key: \"matchReceive\",\n    value: function matchReceive(_ref) {\n      var status = _ref.status;\n      var response = _ref.response;\n      var ref = _ref.ref;\n\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: \"cancelRefEvent\",\n    value: function cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel.off(this.refEvent);\n    }\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n\n      if (this.timeoutTimer) {\n        return;\n      }\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n\n      this.channel.on(this.refEvent, function (payload) {\n        _this.cancelRefEvent();\n        _this.cancelTimeout();\n        _this.receivedResp = payload;\n        _this.matchReceive(payload);\n      });\n\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n  }, {\n    key: \"hasReceived\",\n    value: function hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      this.channel.trigger(this.refEvent, { status: status, response: response });\n    }\n  }]);\n\n  return Push;\n}();\n\nvar Channel = exports.Channel = function () {\n  function Channel(topic, params, socket) {\n    var _this2 = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this2.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", function () {\n      _this2.state = CHANNEL_STATES.joined;\n      _this2.rejoinTimer.reset();\n      _this2.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this2.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this2.rejoinTimer.reset();\n      _this2.socket.log(\"channel\", \"close \" + _this2.topic + \" \" + _this2.joinRef());\n      _this2.state = CHANNEL_STATES.closed;\n      _this2.socket.remove(_this2);\n    });\n    this.onError(function (reason) {\n      if (_this2.isLeaving() || _this2.isClosed()) {\n        return;\n      }\n      _this2.socket.log(\"channel\", \"error \" + _this2.topic, reason);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", function () {\n      if (!_this2.isJoining()) {\n        return;\n      }\n      _this2.socket.log(\"channel\", \"timeout \" + _this2.topic, _this2.joinPush.timeout);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this2.trigger(_this2.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(Channel, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n\n      if (this.joinedOnce) {\n        throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({ event: event, callback: callback });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length <= 2 || arguments[2] === undefined ? this.timeout : arguments[2];\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use channel.join() before pushing events\";\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    // Leaves the channel\n    //\n    // Unsubscribes from server events, and\n    // instructs channel to terminate on server\n    //\n    // Triggers onClose() hooks\n    //\n    // To receive leave acknowledgements, use the a `receive`\n    // hook to bind to the server ack, ie:\n    //\n    //     channel.leave().receive(\"ok\", () => alert(\"left!\") )\n    //\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this3 = this;\n\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n\n      this.state = CHANNEL_STATES.leaving;\n      var onClose = function onClose() {\n        _this3.socket.log(\"channel\", \"leave \" + _this3.topic);\n        _this3.trigger(CHANNEL_EVENTS.close, \"leave\", _this3.joinRef());\n      };\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", function () {\n        return onClose();\n      }).receive(\"timeout\", function () {\n        return onClose();\n      });\n      leavePush.send();\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    // Overridable message hook\n    //\n    // Receives all events for specialized message handling\n    // before dispatching to the channel callbacks.\n    //\n    // Must return the payload, modified or unmodified\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n\n    // private\n\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"sendJoin\",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length <= 0 || arguments[0] === undefined ? this.timeout : arguments[0];\n      if (this.isLeaving()) {\n        return;\n      }\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close;\n      var error = CHANNEL_EVENTS.error;\n      var leave = CHANNEL_EVENTS.leave;\n      var join = CHANNEL_EVENTS.join;\n\n      if (ref && [close, error, leave, join].indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n      var handledPayload = this.onMessage(event, payload, ref);\n      if (payload && !handledPayload) {\n        throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n      }\n\n      this.bindings.filter(function (bind) {\n        return bind.event === event;\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\" + ref;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return Channel;\n}();\n\nvar Socket = exports.Socket = function () {\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/ws\",\n  //                                               \"wss://example.com\"\n  //                                               \"/ws\" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n  //               Defaults to WebSocket with automatic LongPoll fallback.\n  //   timeout - The default timeout in milliseconds to trigger push timeouts.\n  //             Defaults `DEFAULT_TIMEOUT`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  //   params - The optional params to pass when connecting\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n\n  function Socket(endPoint) {\n    var _this4 = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || window.WebSocket || LongPoll;\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.logger = opts.logger || function () {}; // noop\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = opts.params || {};\n    this.endPoint = endPoint + \"/\" + TRANSPORTS.websocket;\n    this.reconnectTimer = new Timer(function () {\n      _this4.disconnect(function () {\n        return _this4.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n\n  _createClass(Socket, [{\n    key: \"protocol\",\n    value: function protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params), { vsn: VSN });\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n      if (uri.charAt(1) === \"/\") {\n        return this.protocol() + \":\" + uri;\n      }\n\n      return this.protocol() + \"://\" + location.host + uri;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback, code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n      }\n      callback && callback();\n    }\n\n    // params - The params to send when connecting, for example `{user_id: userToken}`\n\n  }, {\n    key: \"connect\",\n    value: function connect(params) {\n      var _this5 = this;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = params;\n      }\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.timeout = this.longpollerTimeout;\n      this.conn.onopen = function () {\n        return _this5.onConnOpen();\n      };\n      this.conn.onerror = function (error) {\n        return _this5.onConnError(error);\n      };\n      this.conn.onmessage = function (event) {\n        return _this5.onConnMessage(event);\n      };\n      this.conn.onclose = function (event) {\n        return _this5.onConnClose(event);\n      };\n    }\n\n    // Logs the message. Override `this.logger` for specialized logging. noops by default\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    // Registers callbacks for connection state change events\n    //\n    // Examples\n    //\n    //    socket.onError(function(error){ alert(\"An error occurred\") })\n    //\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n  }, {\n    key: \"onConnOpen\",\n    value: function onConnOpen() {\n      var _this6 = this;\n\n      this.log(\"transport\", \"connected to \" + this.endPointURL(), this.transport.prototype);\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      if (!this.conn.skipHeartbeat) {\n        clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(function () {\n          return _this6.sendHeartbeat();\n        }, this.heartbeatIntervalMs);\n      }\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"onConnClose\",\n    value: function onConnClose(event) {\n      this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"onConnError\",\n    value: function onConnError(error) {\n      this.log(\"transport\", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"triggerChanError\",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n        case SOCKET_STATES.open:\n          return \"open\";\n        case SOCKET_STATES.closing:\n          return \"closing\";\n        default:\n          return \"closed\";\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === \"open\";\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this7 = this;\n\n      var topic = data.topic;\n      var event = data.event;\n      var payload = data.payload;\n      var ref = data.ref;\n\n      var callback = function callback() {\n        return _this7.conn.send(JSON.stringify(data));\n      };\n      this.log(\"push\", topic + \" \" + event + \" (\" + ref + \")\", payload);\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n\n    // Return the next message ref, accounting for overflows\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      if (!this.isConnected()) {\n        return;\n      }\n      this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.makeRef() });\n    }\n  }, {\n    key: \"flushSendBuffer\",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var msg = JSON.parse(rawMessage.data);\n      var topic = msg.topic;\n      var event = msg.event;\n      var payload = msg.payload;\n      var ref = msg.ref;\n\n      this.log(\"receive\", (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\n      this.channels.filter(function (channel) {\n        return channel.isMember(topic);\n      }).forEach(function (channel) {\n        return channel.trigger(event, payload, ref);\n      });\n      this.stateChangeCallbacks.message.forEach(function (callback) {\n        return callback(msg);\n      });\n    }\n  }]);\n\n  return Socket;\n}();\n\nvar LongPoll = exports.LongPoll = function () {\n  function LongPoll(endPoint) {\n    _classCallCheck(this, LongPoll);\n\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.poll();\n  }\n\n  _createClass(LongPoll, [{\n    key: \"normalizeEndpoint\",\n    value: function normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n  }, {\n    key: \"endpointURL\",\n    value: function endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n    }\n  }, {\n    key: \"closeAndRetry\",\n    value: function closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n  }, {\n    key: \"ontimeout\",\n    value: function ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var _this8 = this;\n\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n        if (resp) {\n          var status = resp.status;\n          var token = resp.token;\n          var messages = resp.messages;\n\n          _this8.token = token;\n        } else {\n          var status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(function (msg) {\n              return _this8.onmessage({ data: JSON.stringify(msg) });\n            });\n            _this8.poll();\n            break;\n          case 204:\n            _this8.poll();\n            break;\n          case 410:\n            _this8.readyState = SOCKET_STATES.open;\n            _this8.onopen();\n            _this8.poll();\n            break;\n          case 0:\n          case 500:\n            _this8.onerror();\n            _this8.closeAndRetry();\n            break;\n          default:\n            throw \"unhandled poll status \" + status;\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this9 = this;\n\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\n        if (!resp || resp.status !== 200) {\n          _this9.onerror(status);\n          _this9.closeAndRetry();\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n  }]);\n\n  return LongPoll;\n}();\n\nvar Ajax = exports.Ajax = function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _createClass(Ajax, null, [{\n    key: \"request\",\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (window.XDomainRequest) {\n        var req = new XDomainRequest(); // IE8, IE9\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        var req = window.XMLHttpRequest ? new XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n        new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n  }, {\n    key: \"xdomainRequest\",\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      var _this10 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint);\n      req.onload = function () {\n        var response = _this10.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      // Work around bug in IE9 that requires an attached onprogress handler\n      req.onprogress = function () {};\n\n      req.send(body);\n    }\n  }, {\n    key: \"xhrRequest\",\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      var _this11 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint, true);\n      req.setRequestHeader(\"Content-Type\", accept);\n      req.onerror = function () {\n        callback && callback(null);\n      };\n      req.onreadystatechange = function () {\n        if (req.readyState === _this11.states.complete && callback) {\n          var response = _this11.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(resp) {\n      return resp && resp !== \"\" ? JSON.parse(resp) : null;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(obj, parentKey) {\n      var queryStr = [];\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n          continue;\n        }\n        var paramKey = parentKey ? parentKey + \"[\" + key + \"]\" : key;\n        var paramVal = obj[key];\n        if ((typeof paramVal === \"undefined\" ? \"undefined\" : _typeof(paramVal)) === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n      return queryStr.join(\"&\");\n    }\n  }, {\n    key: \"appendParams\",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return \"\" + url + prefix + this.serialize(params);\n    }\n  }]);\n\n  return Ajax;\n}();\n\nAjax.states = { complete: 4 };\n\nvar Presence = exports.Presence = {\n  syncState: function syncState(currentState, newState, onJoin, onLeave) {\n    var _this12 = this;\n\n    var state = this.clone(currentState);\n    var joins = {};\n    var leaves = {};\n\n    this.map(state, function (key, presence) {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, function (key, newPresence) {\n      var currentPresence = state[key];\n      if (currentPresence) {\n        (function () {\n          var newRefs = newPresence.metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var curRefs = currentPresence.metas.map(function (m) {\n            return m.phx_ref;\n          });\n          var joinedMetas = newPresence.metas.filter(function (m) {\n            return curRefs.indexOf(m.phx_ref) < 0;\n          });\n          var leftMetas = currentPresence.metas.filter(function (m) {\n            return newRefs.indexOf(m.phx_ref) < 0;\n          });\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n          if (leftMetas.length > 0) {\n            leaves[key] = _this12.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        })();\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins: joins, leaves: leaves }, onJoin, onLeave);\n  },\n  syncDiff: function syncDiff(currentState, _ref2, onJoin, onLeave) {\n    var joins = _ref2.joins;\n    var leaves = _ref2.leaves;\n\n    var state = this.clone(currentState);\n    if (!onJoin) {\n      onJoin = function onJoin() {};\n    }\n    if (!onLeave) {\n      onLeave = function onLeave() {};\n    }\n\n    this.map(joins, function (key, newPresence) {\n      var currentPresence = state[key];\n      state[key] = newPresence;\n      if (currentPresence) {\n        var _state$key$metas;\n\n        (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(currentPresence.metas));\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, function (key, leftPresence) {\n      var currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      var refsToRemove = leftPresence.metas.map(function (m) {\n        return m.phx_ref;\n      });\n      currentPresence.metas = currentPresence.metas.filter(function (p) {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  },\n  list: function list(presences, chooser) {\n    if (!chooser) {\n      chooser = function chooser(key, pres) {\n        return pres;\n      };\n    }\n\n    return this.map(presences, function (key, presence) {\n      return chooser(key, presence);\n    });\n  },\n\n  // private\n\n  map: function map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(function (key) {\n      return func(key, obj[key]);\n    });\n  },\n  clone: function clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// Creates a timer that accepts a `timerCalc` function to perform\n// calculated timeout retries, such as exponential backoff.\n//\n// ## Examples\n//\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n//      return [1000, 5000, 10000][tries - 1] || 10000\n//    })\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//    reconnectTimer.scheduleTimeout() // fires after 5000\n//    reconnectTimer.reset()\n//    reconnectTimer.scheduleTimeout() // fires after 1000\n//\n\nvar Timer = function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _createClass(Timer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    // Cancels any previous scheduleTimeout and schedules callback\n\n  }, {\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout() {\n      var _this13 = this;\n\n      clearTimeout(this.timer);\n\n      this.timer = setTimeout(function () {\n        _this13.tries = _this13.tries + 1;\n        _this13.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }]);\n\n  return Timer;\n}();\n\n})(typeof(exports) === \"undefined\" ? window.Phoenix = window.Phoenix || {} : exports);\n  })();\n});","\nrequire.register(\"phoenix_html/priv/static/phoenix_html.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix_html\");\n  (function() {\n    'use strict';\n\nfunction isLinkToSubmitParent(element) {\n  var isLinkTag = element.tagName === 'A';\n  var shouldSubmitParent = element.getAttribute('data-submit') === 'parent';\n\n  return isLinkTag && shouldSubmitParent;\n}\n\nfunction didHandleSubmitLinkClick(element) {\n  while (element && element.getAttribute) {\n    if (isLinkToSubmitParent(element)) {\n      var message = element.getAttribute('data-confirm');\n      if (message === null || confirm(message)) {\n        element.parentNode.submit();\n      };\n      return true;\n    } else {\n      element = element.parentNode;\n    }\n  }\n  return false;\n}\n\n// for links with HTTP methods other than GET\nwindow.addEventListener('click', function (event) {\n  if (event.target && didHandleSubmitLinkClick(event.target)) {\n    event.preventDefault();\n    return false;\n  }\n}, false);\n  })();\n});","/*====================================================================\r\n *\r\n * This file is used to setup all the necessary tools the other scripts need.\r\n *\r\n =====================================================================*/\r\n\r\n//Current username\r\nwindow.currUser = \"\";\r\n//Used to figure out how to draw the other user's mouse pointers to screen.\r\nwindow.cursorStates = {};\r\n// Drawing variables.\r\nwindow.drawing = false;\r\nwindow.mousePos = { x:0, y:0 };\r\nwindow.lastPos = mousePos;\r\n\r\n// Set up the Mouse Layer\r\nwindow.mouseCanvas = document.getElementById(\"mouse-canvas\");\r\nwindow.mouseCtx = mouseCanvas.getContext(\"2d\");\r\n\r\n// Set up the Drawing Layer\r\nwindow.collabCanvas = document.getElementById(\"collab-canvas\");\r\nwindow.ctx = collabCanvas.getContext(\"2d\");\r\nctx.strokeStyle = \"#222222\";\r\nctx.lineWidth = 2;\r\n","import \"phoenix_html\"\r\nimport {Socket} from \"phoenix\"\r\n\r\nfunction clearCanvas() {\r\n  collabCanvas.width = collabCanvas.width;\r\n}\r\n\r\n// Initialize Socket.\r\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}});\r\n\r\n//Connect socket.\r\nsocket.connect();\r\nwindow.channel = socket.channel(\"room:lobby\", {});\r\n\r\nchannel.join()\r\n  .receive(\"ok\", resp => { console.log(\"Joined successfully\", resp) })\r\n  .receive(\"error\", resp => { console.log(\"Unable to join\", resp) });\r\n\r\n//Socket events\r\n//==========================\r\nchannel.on(\"drawline\", payload => {\r\n    ctx.moveTo(payload.from.x, payload.from.y);\r\n    ctx.lineTo(payload.to.x, payload.to.y);\r\n    ctx.stroke();\r\n});\r\n\r\nchannel.on(\"clear\", payload => {\r\n  console.log(\"Clearing canvas.\");\r\n  clearCanvas();\r\n});\r\n\r\nchannel.on(\"mousemove\", payload => {\r\n  var img = document.getElementById(\"cursor\");\r\n  img.display=\"inline\";\r\n  mouseCanvas.width = mouseCanvas.width;\r\n  if(payload.name != currUser)\r\n  {\r\n    cursorStates[payload.name] = {\"x\" : payload.position.x, \"y\" :  payload.position.y}\r\n  }\r\n\r\n  //Iterate through every cursor position and draw them all back. This may be slow...\r\n  var cursorKeys = Object.keys(cursorStates);\r\n  cursorKeys.forEach(function(currKey){\r\n    mouseCtx.drawImage(img, cursorStates[currKey].x, cursorStates[currKey].y);\r\n  });\r\n});\r\n","import \"./setup.js\"\nimport \"./roomcontroller.js\"\nimport \"./socket.js\"\n\n$(document).ready(function(){\n   if(!currUser)\n   {\n     var baseName = \"Anon\" + Math.floor(Math.random() * 100);\n     currUser = baseName;\n     $(\"#username\").val(baseName);\n     console.log(cursorStates[currUser]);\n   }\n});\n\n(function() {\n\n\t// Get a regular interval for drawing to the screen\n\twindow.requestAnimFrame = (function (callback) {\n\t\treturn window.requestAnimationFrame ||\n\t\t\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\t\t\twindow.oRequestAnimationFrame ||\n\t\t\t\t\twindow.msRequestAnimaitonFrame ||\n\t\t\t\t\tfunction (callback) {\n\t\t\t\t\t \twindow.setTimeout(callback, 1000/60);\n\t\t\t\t\t};\n\t})();\n\t// Set up the UI\n\tvar clearBtn = document.getElementById(\"clearBtn\");\n\tclearBtn.addEventListener(\"click\", function (e) {\n    channel.push(\"clear\", { });\n\t\tclearCanvas();\n\t}, false);\n\n  var changeUserBtn = document.getElementById(\"enterUser\");\n  changeUserBtn.addEventListener(\"click\", function (e) {\n      channel.push(\"userJoined\", { });\n  }, false);\n\n  //Drawing events for desktop\n\tmouseCanvas.addEventListener(\"mousedown\", function (e) {\n\t\tdrawing = true;\n\t\tlastPos = getMousePos(collabCanvas, e);\n\t}, false);\n\tmouseCanvas.addEventListener(\"mouseup\", function (e) {\n\t\tdrawing = false;\n\t}, false);\n\tmouseCanvas.addEventListener(\"mousemove\", function (e) {\n\t\tmousePos = getMousePos(collabCanvas, e);\n    channel.push(\"mousemove\", {\n      \"name\": currUser,\n      \"position\" : {\n        \"x\" : mousePos.x,\n        \"y\" : mousePos.y\n      }\n    });\n\t}, false);\n\n\t// Drawing events for Mobile\n\tcollabCanvas.addEventListener(\"touchstart\", function (e) {\n\t\tmousePos = getTouchPos(collabCanvas, e);\n\t\tvar touch = e.touches[0];\n\t\tvar mouseEvent = new MouseEvent(\"mousedown\", {\n\t\t\tclientX: touch.clientX,\n\t\t\tclientY: touch.clientY\n\t\t});\n\t\tcanvas.dispatchEvent(mouseEvent);\n\t}, false);\n\tcollabCanvas.addEventListener(\"touchend\", function (e) {\n\t\tvar mouseEvent = new MouseEvent(\"mouseup\", {});\n\t\tcanvas.dispatchEvent(mouseEvent);\n\t}, false);\n\tcollabCanvas.addEventListener(\"touchmove\", function (e) {\n\t\tvar touch = e.touches[0];\n\t\tvar mouseEvent = new MouseEvent(\"mousemove\", {\n\t\t\tclientX: touch.clientX,\n\t\t\tclientY: touch.clientY\n\t\t});\n\t\tcanvas.dispatchEvent(mouseEvent);\n\t}, false);\n\n\t// Prevent scrolling when touching the canvas\n\tdocument.body.addEventListener(\"touchstart\", function (e) {\n\t\tif (e.target == canvas) {\n\t\t\te.preventDefault();\n\t\t}\n\t}, false);\n\tdocument.body.addEventListener(\"touchend\", function (e) {\n\t\tif (e.target == canvas) {\n\t\t\te.preventDefault();\n\t\t}\n\t}, false);\n\tdocument.body.addEventListener(\"touchmove\", function (e) {\n\t\tif (e.target == canvas) {\n\t\t\te.preventDefault();\n\t\t}\n\t}, false);\n\n\t// Get the position of the mouse relative to the canvas\n\tfunction getMousePos(canvasDom, mouseEvent) {\n\t\tvar rect = canvasDom.getBoundingClientRect();\n\t\treturn {\n\t\t\tx: mouseEvent.clientX - rect.left,\n\t\t\ty: mouseEvent.clientY - rect.top\n\t\t};\n\t}\n\n\t// Get the position of a touch relative to the canvas\n\tfunction getTouchPos(canvasDom, touchEvent) {\n\t\tvar rect = canvasDom.getBoundingClientRect();\n\t\treturn {\n\t\t\tx: touchEvent.touches[0].clientX - rect.left,\n\t\t\ty: touchEvent.touches[0].clientY - rect.top\n\t\t};\n\t}\n\n\t// Draw to the canvas\n\tfunction renderCanvas() {\n\t\tif (drawing) {\n      if(lastPos.x != mousePos.x || lastPos.y != mousePos.y)\n      {\n        channel.push(\"drawline\", {\n          from : {\n            x : lastPos.x,\n            y : lastPos.y\n          },\n          to : {\n            x : mousePos.x,\n            y : mousePos.y\n          }\n        });\n      }\n\t\t\tctx.moveTo(lastPos.x, lastPos.y);\n\t\t\tctx.lineTo(mousePos.x, mousePos.y);\n\t\t\tctx.stroke();\n\t\t\tlastPos = mousePos;\n\t\t}\n\t}\n\n\t// Allow for animation\n\t(function drawLoop () {\n\t\trequestAnimFrame(drawLoop);\n\t\trenderCanvas();\n\t})();\n\n})();\n","yachtApp.controller('RoomController', function RoomController($scope) {\r\n  $scope.users = [\r\n    {\r\n      name: 'Bilbo Baggins',\r\n      color: '100,100,100'\r\n    }, {\r\n      name: 'Mike Wazawski',\r\n      color: '150,0,150'\r\n    }, {\r\n      name: 'Samus Aran',\r\n      color: '255,0,0'\r\n    }\r\n  ];\r\n});\r\n","/*====================================================================\r\n *\r\n * This file is used to setup all the necessary tools the other scripts need.\r\n *\r\n =====================================================================*/\r\n\r\n// Setup Angular\r\n// Define the `phonecatApp` module\r\nwindow.yachtApp = angular.module('yachtApp', []);\r\n\r\n//Setup Canvas \"stuff\"\r\n//========================\r\nwindow.currUser = \"\";\r\nwindow.cursorStates = {};\r\nwindow.drawing = false;\r\nwindow.mousePos = { x:0, y:0 };\r\nwindow.lastPos = mousePos;\r\n\r\n// Mouse Layer\r\nwindow.mouseCanvas = document.getElementById(\"mouse-canvas\");\r\nwindow.mouseCtx = mouseCanvas.getContext(\"2d\");\r\n\r\n// Drawing Layer\r\nwindow.collabCanvas = document.getElementById(\"collab-canvas\");\r\nwindow.ctx = collabCanvas.getContext(\"2d\");\r\nctx.strokeStyle = \"#222222\";\r\nctx.lineWidth = 2;\r\n","import \"phoenix_html\"\r\nimport {Socket} from \"phoenix\"\r\n\r\nfunction clearCanvas() {\r\n  collabCanvas.width = collabCanvas.width;\r\n}\r\n\r\n// Initialize Socket.\r\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}});\r\n\r\n//Connect socket.\r\nsocket.connect();\r\nwindow.channel = socket.channel(\"room:lobby\", {});\r\n\r\nchannel.join()\r\n  .receive(\"ok\", resp => { console.log(\"Joined successfully\", resp) })\r\n  .receive(\"error\", resp => { console.log(\"Unable to join\", resp) });\r\n\r\n//Socket events\r\n//==========================\r\nchannel.on(\"drawline\", payload => {\r\n    ctx.moveTo(payload.from.x, payload.from.y);\r\n    ctx.lineTo(payload.to.x, payload.to.y);\r\n    ctx.stroke();\r\n});\r\n\r\nchannel.on(\"clear\", payload => {\r\n  console.log(\"Clearing canvas.\");\r\n  clearCanvas();\r\n});\r\n\r\nchannel.on(\"mousemove\", payload => {\r\n  var img = document.getElementById(\"cursor\");\r\n  img.display=\"inline\";\r\n  mouseCanvas.width = mouseCanvas.width;\r\n  if(payload.name != currUser)\r\n  {\r\n    cursorStates[payload.name] = {\"x\" : payload.position.x, \"y\" :  payload.position.y}\r\n  }\r\n\r\n  //Iterate through every cursor position and draw them all back. This may be slow...\r\n  var cursorKeys = Object.keys(cursorStates);\r\n  cursorKeys.forEach(function(currKey){\r\n    mouseCtx.drawImage(img, cursorStates[currKey].x, cursorStates[currKey].y);\r\n  });\r\n});\r\n\r\nchannel.on(\"userJoined\", payload =>{\r\n  console.log(payload);\r\n});\r\n"]}